{% load static %}
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Advanced Model Viewer</title>

<style>
body{
    margin:0;
    font-family:Arial;
    background:#0f172a;
    color:#e2e8f0;
}

h1{padding:15px;}

.main{
    display:flex;
    gap:20px;
    padding:20px;
}

#viewer3d{
    width:700px;
    height:500px;
    background:#020617;
    border-radius:10px;
}

.panel{
    width:300px;
    background:#020617;
    padding:15px;
    border-radius:10px;
}

.panel h3{margin-top:10px;}

.panel input, .panel button{
    width:100%;
    margin-bottom:8px;
}

button{
    padding:8px;
    background:#1e293b;
    border:none;
    color:white;
    border-radius:6px;
    cursor:pointer;
}

button:hover{
    background:#334155;
}
</style>
</head>

<body>

<h1>Advanced Model Viewer</h1>

<div class="main">

<div id="viewer3d"></div>

<div class="panel">

<h3>Appearance</h3>
<input type="color" id="colorPicker" value="#38bdf8">
<label><input type="checkbox" id="wireframeToggle"> Wireframe</label>
Metalness <input type="range" id="metalSlider" min="0" max="1" step="0.01" value="0.5">
Roughness <input type="range" id="roughSlider" min="0" max="1" step="0.01" value="0.3">
Light <input type="range" id="lightSlider" min="0" max="5" step="0.1" value="2">

<h3>Helpers</h3>
<button id="gridBtn">Toggle Grid</button>
<button id="axisBtn">Toggle Axis</button>

<h3>Transform</h3>
Scale <input type="range" id="scaleSlider" min="0.1" max="3" step="0.1" value="1">

Rotate X <input type="range" id="rotX" min="0" max="360" value="0">
Rotate Y <input type="range" id="rotY" min="0" max="360" value="0">
Rotate Z <input type="range" id="rotZ" min="0" max="360" value="0">

Position X <input type="range" id="posX" min="-10" max="10" step="0.1" value="0">
Position Y <input type="range" id="posY" min="-10" max="10" step="0.1" value="0">
Position Z <input type="range" id="posZ" min="-10" max="10" step="0.1" value="0">

<h3>Animation</h3>
<button id="autoRotateBtn">Auto Rotate: ON</button>

<h3>Export</h3>
<button id="screenshotBtn">Take Screenshot</button>

<div id="angleDisplay" style="margin-top:10px;"></div>

</div>
</div>

{{ model_id|json_script:"model-id-data" }}

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>
<script type="module">
import * as THREE from "{% static 'three/three.module.js' %}";
import { OrbitControls } from "{% static 'three/OrbitControls.js' %}";

const MODEL_ID = JSON.parse(document.getElementById("model-id-data").textContent);
const API_URL = `/api/models/${MODEL_ID}/`;

async function loadModel() {

    const response = await fetch(API_URL);
    const data = await response.json();

    const container = document.getElementById("viewer3d");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f172a);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        2000
    );

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const light = new THREE.DirectionalLight(0xffffff,2);
    light.position.set(10,15,10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff,0.4));

    // Create geometry based on type
    let geometry;
    if(data.type.toLowerCase() === "sphere") {
        geometry = new THREE.SphereGeometry(data.dimensions.width/2,32,32);
    } else if(data.type.toLowerCase() === "cube") {
        geometry = new THREE.BoxGeometry(
            data.dimensions.width,
            data.dimensions.height,
            data.dimensions.depth
        );
    } else {
        geometry = new THREE.CylinderGeometry(
            data.dimensions.width/2,
            data.dimensions.width/2,
            data.dimensions.height,
            32
        );
    }

    const material = new THREE.MeshStandardMaterial({
        color: 0x38bdf8,
        metalness: 0.5,
        roughness: 0.3
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Auto center + fit
    const box = new THREE.Box3().setFromObject(mesh);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    mesh.position.sub(center);

    // Camera setup with dynamic near/far planes
    const maxDim = Math.max(size.x, size.y, size.z);
    camera.position.set(0, maxDim, maxDim*2);
    camera.near = maxDim / 100;
    camera.far = maxDim * 100;
    camera.updateProjectionMatrix();

    // OrbitControls limits
    controls.target.set(0,0,0);
    controls.update();
    controls.minDistance = maxDim / 10;
    controls.maxDistance = maxDim * 10;

    // Helpers
    const grid = new THREE.GridHelper(50,50);
    scene.add(grid);
    const axes = new THREE.AxesHelper(5);
    scene.add(axes);

    // UI Controls
    colorPicker.oninput = e => material.color.set(e.target.value);
    wireframeToggle.onchange = e => material.wireframe = e.target.checked;
    metalSlider.oninput = e => material.metalness = e.target.value;
    roughSlider.oninput = e => material.roughness = e.target.value;
    lightSlider.oninput = e => light.intensity = e.target.value;

    gridBtn.onclick = () => grid.visible = !grid.visible;
    axisBtn.onclick = () => axes.visible = !axes.visible;

    scaleSlider.oninput = e => mesh.scale.set(e.target.value,e.target.value,e.target.value);
    rotX.oninput = e => mesh.rotation.x = THREE.MathUtils.degToRad(e.target.value);
    rotY.oninput = e => mesh.rotation.y = THREE.MathUtils.degToRad(e.target.value);
    rotZ.oninput = e => mesh.rotation.z = THREE.MathUtils.degToRad(e.target.value);
    posX.oninput = e => mesh.position.x = e.target.value;
    posY.oninput = e => mesh.position.y = e.target.value;
    posZ.oninput = e => mesh.position.z = e.target.value;

    // Auto rotate
    let autoRotate = true;
    autoRotateBtn.onclick = () => {
        autoRotate = !autoRotate;
        autoRotateBtn.innerText = autoRotate ? "Auto Rotate: ON" : "Auto Rotate: OFF";
    };

    // Screenshot
    screenshotBtn.onclick = () => {
        renderer.render(scene, camera);
        const link = document.createElement("a");
        link.download = "model.png";
        link.href = renderer.domElement.toDataURL();
        link.click();
    };

    // Responsive
    window.addEventListener("resize", () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });

    // Animation
    function animate() {
        requestAnimationFrame(animate);
        if(autoRotate) mesh.rotation.y += 0.01;

        const degX = THREE.MathUtils.radToDeg(mesh.rotation.x).toFixed(1);
        const degY = THREE.MathUtils.radToDeg(mesh.rotation.y).toFixed(1);
        const degZ = THREE.MathUtils.radToDeg(mesh.rotation.z).toFixed(1);

        angleDisplay.innerHTML = `Rotation → X:${degX}° Y:${degY}° Z:${degZ}°`;

        controls.update();
        renderer.render(scene, camera);
    }
    animate();
}

loadModel();
</script>
