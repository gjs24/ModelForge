{% load static %}
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Advanced Model Viewer</title>

<style>
body{
    margin:0;
    font-family:Arial;
    background:#0f172a;
    color:#e2e8f0;
}

h1{padding:15px;}

.main{
    display:flex;
    gap:20px;
    padding:20px;
}

#viewer3d{
    width:700px;
    height:500px;
    background:#020617;
    border-radius:10px;
}

.panel{
    width:300px;
    background:#020617;
    padding:15px;
    border-radius:10px;
}

.panel h3{margin-top:10px;}

.panel input, .panel button{
    width:100%;
    margin-bottom:8px;
}

button{
    padding:8px;
    background:#1e293b;
    border:none;
    color:white;
    border-radius:6px;
    cursor:pointer;
}

button:hover{
    background:#334155;
}
</style>
</head>

<body>

<h1>Advanced Model Viewer</h1>

<div class="main">

<div id="viewer3d"></div>

<div class="panel">

<h3>Appearance</h3>
<input type="color" id="colorPicker" value="#38bdf8">
<label><input type="checkbox" id="wireframeToggle"> Wireframe</label>
Metalness <input type="range" id="metalSlider" min="0" max="1" step="0.01" value="0.5">
Roughness <input type="range" id="roughSlider" min="0" max="1" step="0.01" value="0.3">
Light <input type="range" id="lightSlider" min="0" max="5" step="0.1" value="2">

<h3>Helpers</h3>
<button id="gridBtn">Toggle Grid</button>
<button id="axisBtn">Toggle Axis</button>

<h3>Transform</h3>
Scale <input type="range" id="scaleSlider" min="0.1" max="3" step="0.1" value="1">

Rotate X <input type="range" id="rotX" min="0" max="360" value="0">
Rotate Y <input type="range" id="rotY" min="0" max="360" value="0">
Rotate Z <input type="range" id="rotZ" min="0" max="360" value="0">

Position X <input type="range" id="posX" min="-10" max="10" step="0.1" value="0">
Position Y <input type="range" id="posY" min="-10" max="10" step="0.1" value="0">
Position Z <input type="range" id="posZ" min="-10" max="10" step="0.1" value="0">

<h3>Animation</h3>
<button id="autoRotateBtn">Auto Rotate: ON</button>

<h3>Reset</h3>
<button id="resetBtn">Reset Position</button>
<button id="resetViewBtn">Reset View</button>

<h3>Camera Zoom</h3>
Zoom Speed <input type="range" id="zoomSpeedSlider" min="0.1" max="5" step="0.1" value="1">



<h3>Export</h3>
<button id="screenshotBtn">Take Screenshot</button>

<div id="angleDisplay" style="margin-top:10px;"></div>

</div>
</div>

{{ model_id|json_script:"model-id-data" }}

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { RGBELoader } from "three/addons/loaders/RGBELoader.js";


const MODEL_ID = JSON.parse(document.getElementById("model-id-data").textContent);
const API_URL = `/api/models/${MODEL_ID}/`;

let mesh, material;

async function loadModel() {

    const response = await fetch(API_URL);
    const data = await response.json();

    const container = document.getElementById("viewer3d");

    /* ================= SCENE ================= */

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f172a);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        2000
    );

    camera.position.set(0, 5, 10);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    /* ================= LIGHT ================= */

    const light = new THREE.DirectionalLight(0xffffff,2);
    light.position.set(10,15,10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff,0.4));

    /* ================= PROMPT PARSER ================= */

    const prompt = (data.name || "").toLowerCase();
    let color = data.color || "#38bdf8";
    let scaleFactor = 1;

    if(prompt.includes("red")) color = "#ff0000";
    if(prompt.includes("green")) color = "#22c55e";
    if(prompt.includes("blue")) color = "#3b82f6";
    if(prompt.includes("yellow")) color = "#eab308";
    if(prompt.includes("purple")) color = "#a855f7";

    if(prompt.includes("big")) scaleFactor = 2;
    if(prompt.includes("small")) scaleFactor = 0.6;

    /* ================= GEOMETRY ================= */

    if(prompt.includes("apple")) {

        const group = new THREE.Group();

        // Body
        const bodyGeometry = new THREE.SphereGeometry(2, 64, 64);
        bodyGeometry.scale(1, 0.9, 1);

        material = new THREE.MeshStandardMaterial({
            color: new THREE.Color(color),
            metalness: 0.3,
            roughness: 0.6
        });

        const body = new THREE.Mesh(bodyGeometry, material);
        group.add(body);

        // Stem
        const stemGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.6, 16);
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        stem.position.y = 2;
        group.add(stem);

        // Leaf
        const leafGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);

        leaf.scale.set(1.5, 0.2, 1);
        leaf.rotation.z = Math.PI / 4;
        leaf.position.set(0.6, 2.1, 0);

        group.add(leaf);

        mesh = group;

    } else {

        let geometry;

        if(prompt.includes("sphere"))
            geometry = new THREE.SphereGeometry(2, 32, 32);
        else if(prompt.includes("cube"))
            geometry = new THREE.BoxGeometry(3,3,3);
        else if(prompt.includes("cylinder"))
            geometry = new THREE.CylinderGeometry(1.5,1.5,4,32);
        else
            geometry = new THREE.BoxGeometry(3,3,3);

        material = new THREE.MeshStandardMaterial({
            color: new THREE.Color(color),
            metalness: 0.5,
            roughness: 0.3
        });

        mesh = new THREE.Mesh(geometry, material);
    }

    mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
    scene.add(mesh);

    /* ================= CAMERA FIT ================= */

    const box = new THREE.Box3().setFromObject(mesh);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    mesh.position.sub(center);

    const maxDim = Math.max(size.x, size.y, size.z);
    camera.position.set(0, maxDim, maxDim * 2);
    controls.target.set(0,0,0);
    controls.update();

    /* ================= UI CONTROLS ================= */

    colorPicker.oninput = e => material?.color.set(e.target.value);
    wireframeToggle.onchange = e => {
        if(material) material.wireframe = e.target.checked;
    };

    metalSlider.oninput = e => {
        if(material) material.metalness = e.target.value;
    };

    roughSlider.oninput = e => {
        if(material) material.roughness = e.target.value;
    };

    lightSlider.oninput = e => light.intensity = e.target.value;

    scaleSlider.oninput = e => {
        mesh.scale.set(e.target.value, e.target.value, e.target.value);
    };

    rotX.oninput = e => mesh.rotation.x = THREE.MathUtils.degToRad(e.target.value);
    rotY.oninput = e => mesh.rotation.y = THREE.MathUtils.degToRad(e.target.value);
    rotZ.oninput = e => mesh.rotation.z = THREE.MathUtils.degToRad(e.target.value);

    posX.oninput = e => mesh.position.x = e.target.value;
    posY.oninput = e => mesh.position.y = e.target.value;
    posZ.oninput = e => mesh.position.z = e.target.value;

    /* ================= AUTO ROTATE ================= */

    let autoRotate = true;
    autoRotateBtn.onclick = () => {
        autoRotate = !autoRotate;
        autoRotateBtn.innerText = autoRotate ? "Auto Rotate: ON" : "Auto Rotate: OFF";
    };

    /* ================= SCREENSHOT ================= */

    screenshotBtn.onclick = async () => {

        renderer.render(scene, camera);

        const imageData = renderer.domElement.toDataURL("image/png");

        // download locally
        const link = document.createElement("a");
        link.download = "model.png";
        link.href = imageData;
        link.click();

        // send to backend (save one by one)
        await fetch(`/api/models/${MODEL_ID}/save_screenshot/`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ image: imageData })
        });
    };

    /* ================= ANIMATION ================= */

    function animate() {
        requestAnimationFrame(animate);

        if(autoRotate) mesh.rotation.y += 0.01;

        controls.update();
        renderer.render(scene, camera);
    }


    /* ================= HDR ENVIRONMENT ================= */

const pmremGenerator = new THREE.PMREMGenerator(renderer);
pmremGenerator.compileEquirectangularShader();

new RGBELoader()
    .load("/static/hdr/studio.hdr", function (texture) {

        const envMap = pmremGenerator.fromEquirectangular(texture).texture;

        scene.environment = envMap;
        scene.background = envMap;

        texture.dispose();
        pmremGenerator.dispose();
    });
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    /* ================= HELPERS ================= */

let gridHelper = new THREE.GridHelper(20, 20);
let axisHelper = new THREE.AxesHelper(5);

let gridVisible = false;
let axisVisible = false;

gridBtn.onclick = () => {
    gridVisible = !gridVisible;
    if (gridVisible) {
        scene.add(gridHelper);
    } else {
        scene.remove(gridHelper);
    }
};

axisBtn.onclick = () => {
    axisVisible = !axisVisible;
    if (axisVisible) {
        scene.add(axisHelper);
    } else {
        scene.remove(axisHelper);
    }
};


/* ================= RESET POSITION ================= */

resetBtn.onclick = () => {
    mesh.position.set(0, 0, 0);
    mesh.rotation.set(0, 0, 0);
    mesh.scale.set(1, 1, 1);
};


/* ================= RESET VIEW ================= */

resetViewBtn.onclick = () => {

    const box = new THREE.Box3().setFromObject(mesh);
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);

    camera.position.set(0, maxDim, maxDim * 2);
    controls.target.set(0, 0, 0);
    controls.update();
};


/* ================= ZOOM SPEED ================= */

zoomSpeedSlider.oninput = e => {
    controls.zoomSpeed = parseFloat(e.target.value);
};
/* ================= SNAP ROTATION ================= */

function snapTo90() {
    const snap = deg => Math.round(deg / 90) * 90;

    const x = THREE.MathUtils.radToDeg(mesh.rotation.x);
    const y = THREE.MathUtils.radToDeg(mesh.rotation.y);
    const z = THREE.MathUtils.radToDeg(mesh.rotation.z);

    mesh.rotation.x = THREE.MathUtils.degToRad(snap(x));
    mesh.rotation.y = THREE.MathUtils.degToRad(snap(y));
    mesh.rotation.z = THREE.MathUtils.degToRad(snap(z));
}

// Snap when user releases slider
rotX.onchange = snapTo90;
rotY.onchange = snapTo90;
rotZ.onchange = snapTo90;
/* ================= SMOOTH CAMERA RESET ================= */

resetViewBtn.onclick = () => {

    const box = new THREE.Box3().setFromObject(mesh);
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);

    const targetPosition = new THREE.Vector3(0, maxDim, maxDim * 2);
    const startPosition = camera.position.clone();

    let progress = 0;

    function animateCamera() {
        progress += 0.03;

        camera.position.lerpVectors(startPosition, targetPosition, progress);
        controls.target.set(0,0,0);
        controls.update();

        if(progress < 1) {
            requestAnimationFrame(animateCamera);
        }
    }

    animateCamera();
};
/* ================= PROFESSIONAL LIGHTING ================= */

const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(10, 15, 10);
scene.add(dirLight);

const fillLight = new THREE.DirectionalLight(0xffffff, 1);
fillLight.position.set(-10, 5, -5);
scene.add(fillLight);

const backLight = new THREE.DirectionalLight(0xffffff, 0.8);
backLight.position.set(0, 10, -15);
scene.add(backLight);

const ambient = new THREE.AmbientLight(0xffffff, 0.3);
scene.add(ambient);

// Control main light intensity
lightSlider.oninput = e => {
    dirLight.intensity = e.target.value;
};
/* ================= PROFESSIONAL MODE ================= */

window.addEventListener("keydown", (e) => {

    // F = Fullscreen
    if(e.key === "f") {
        if (!document.fullscreenElement) {
            renderer.domElement.requestFullscreen();
        } else {
            document.exitFullscreen();
        }
    }

    // G = Toggle Grid
    if(e.key === "g") gridBtn.click();

    // A = Toggle Axis
    if(e.key === "a") axisBtn.click();

    // R = Reset View
    if(e.key === "r") resetViewBtn.click();

    // S = Snap Rotation
    if(e.key === "s") snapTo90();
});


    animate();
}

loadModel();
</script>
